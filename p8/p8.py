#p8.py

import sys
import math
import numpy as np
import matplotlib.pyplot as plt
from qwop2 import *

def main():
    if(sys.argv[1] == "1"):
        part1()
    if(sys.argv[1] == "2"):
        part2()

#All of these are with the old qwop file
#7.4
#start_plan = [0.65980176224377485, -2.7172428143435314, -1.5723324626903228, -0.59121809087747557, -2.8549037794010208, 0.49846404403056765, -0.52990693071125539, 1.8486330736917895, -0.66755262592025966, -0.041905629165956762, -0.30987212381459295, 0.40469535078689267, -0.60497090384147689, -0.61688010582972286, 0.3477794672052858, 1.224506896457918, 1.0355479247754931, 1.0515309331360281, -0.082705962864397811, -0.3846631468070501, -0.56477151100990564, -0.47435224525679476, 0.09022898998720795, 0.91276842114242973, -0.064869083673449179, -0.003190111707468482, -0.71195459633237723, -0.69725517001777682, -0.97755819020468571, 0.078504408496392425, -0.41131687529031119, 0.0093130678842596876, -0.16557130083628327, 0.047549330813722028, -0.12942253653310476, -0.83329993459537322, -0.60888624222189947, 0.96487578891936454, -0.66419143156386162, 0.22241886216904483]
#8.5
#start_plan = [0.7297437113650187, -2.6853819914746526, -1.2638386437557152, -0.91117072992707882, -3.0545105349697583, 0.34083215249084531, -0.83279114086837258, 1.8227909798935999, -0.74225610221405114, -0.053096609752618443, -0.30767567412579688, 0.38588401785109516, -0.4931679636023184, -0.65914016528157138, 0.50516400904872749, 1.1597191763802432, 1.231291209911767, 1.0464179315583446, 0.070952666511598914, -0.36433019281987128, -0.84881708562660374, -0.46740790326646109, 0.50623559959204334, 1.0553556884690622, 0.31178800939732659, 0.30892825322381129, -1.052963447711265, -1.2059355345149152, -0.46461465633447196, -0.17811334077604399, -0.37599752340270293, 0.11364296727061697, -0.12609897853666699, 0.062857883461474584, -0.10313547422842961, -0.83378416058800953, -0.55709545722794473, 0.96711251350269112, -0.64975489071221382, 0.22571387443208302]
#4.3
#start_plan = [1.615587820776397, 0.6945940178976866, -0.81496393087546426, -0.27342647889877097, -1.7029356145948154, -0.092344279062605727, 0.75574831054704239, 0.1582465508447847, 0.35322297722819834, -0.88951301982579811, -0.13386815607363084, -0.48680490671974541, -0.096531708014263057, 0.099985204486601309, -0.30716770453846354, 0.10166272016336199, -0.53324622928983423, -0.85273070002987905, -0.2573358805180615, 1.0247870571080782, 0.60259014270041844, 0.52875189769236897, -0.10746005638828732, 0.71795797312040699, -0.57436110695543963, -0.16253119009381226, 0.045578299318838673, 0.87630185383102643, -0.24634744821103663, 0.95405353004882809, 0.56422080200881963, 0.72449618216507539, -0.71527385045989111, -0.12154117972387685, -0.4938191692113319, 0.072391985487706145, 0.497333760901502, 0.67502672204499181, -0.86967133129934704, -0.66177638129445515]
#11.5
#start_plan = [1.4008089863986921, -0.13917877964150951, -0.61061823222546741, -2.0220931657631049, -3.7904971731588049, -0.19534058720704037, -0.91822024478712161, 1.7618198842003558, -1.2496528368408979, -0.039952487207143464, -0.64352792621658517, 0.51021214891451527, -0.83558773989385104, -0.6210923085937603, 0.39821825451552662, 1.1874673963952003, 1.6402647448458372, 1.0195654697854437, 0.48308390551910402, -0.37100324827774905, -1.2605103745759278, -0.34551677380619628, 0.18599606571305721, 0.8416804776569633, -0.17472486402664156, -0.65691610213418272, -1.59637040170116, -1.9805807040803682, 0.77376295509301629, -0.57840861794468645, 0.56032586871990764, 3.8933162934484979, -0.72436185472593295, -0.094577888301985935, 3.1341710933172262, -4.6321775959889679, -0.21116079672889077, 2.5438843618794613, -3.6239892399710318, 0.39395034954146702]

#These are for the new one
# 6.9
#start_plan = [0.035534872394321529, 0.84085108911516426, -0.56346196154346995, -0.18576258789029318, 0.37657803113608473, 0.74222679392355151, 0.39007905374581925, 0.62655900157667566, -0.16561060708443245, -0.029928659700814673, -0.26509197569819681, -0.40568041087408069, -0.99740272891957105, -1.0, -0.91411213022590943, 0.3795031778657702, 0.41554034668508194, 0.91663827173219659, -1.0, 0.56839935799033603, -1.0, -0.78576534456553082, -0.27812172561484377, 1.0, -1.0, -0.50391753398440353, -0.76889132703766427, -1.0, 0.043110472447635918, -0.27703216182161972, 0.87359469863838546, 1.0, -0.53416498160012205, -1.0, 0.73870012247097727, -1.0, 0.31672721539902193, 1.0, -1.0, 1.0]
# 7.1
#start_plan = [0.035534872394321529, 0.84085108911516426, -0.56346196154346995, -0.18576258789029318, 0.37657803113608473, 0.74222679392355151, 0.39007905374581925, 0.62655900157667566, -0.16561060708443245, -0.029928659700814673, -0.10525597877810336, -0.43543982883542554, -1.0, -0.97026861660032182, -0.9317425335787568, 0.37900045249832959, 0.4010780812323459, 0.95166594111004277, -1.0, 0.59818905601978922, -1.0, -0.78215204320800624, -0.33543718276425882, 1.0, -1.0, -0.47638494182124946, -0.82162852710892098, -0.94213162025857855, -0.0076247637610240967, -0.23306650527134323, 0.83682492118395368, 1.0, -0.53302512079950237, -1.0, 0.74065526169183782, -0.99923301174931112, 0.31665338513217167, 1.0, -1.0, 1.0]
# 7.25
start_plan = [0.035534872394321529, 0.84085108911516426, -0.56346196154346995, -0.18576258789029318, 0.37657803113608473, 0.74222679392355151, 0.39007905374581925, 0.62655900157667566, -0.16561060708443245, -0.029928659700814673, -0.10525597877810336, -0.43543982883542554, -1.0, -0.97026861660032182, -0.9317425335787568, 0.37900045249832959, 0.4010780812323459, 0.95166594111004277, -1.0, 0.59818905601978922, -1.0, -1.0, -0.67096857585195524, 1.0, -0.93224047913435115, -0.38369771469443442, -0.80291295612104674, -0.8327407135092797, 0.088986376463123615, -0.12933194653889624, 1.0, 1.0, -0.61729181393405608, -1.0, 0.62658540636382409, -1.0, 0.31175040396807469, 1.0, -1.0, 1.0]
# 7.5 (from justin)
start_plan = [0.24559, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0]
#def swarm
start_plan = [0.91085,2646.7,2236,3195.6,7233.5,2045.6,2780,8441.3,-7547.5,-202.72,-2670,-6066,2498,-2459.9,1716.6,-1079.4,368.13,-5138.8,4533.5,1975,-1646.3,-2013,-2509.7,3378.6,3438.7,1696.7,-1817.1,-1018.6,-7073.5,-2344.5,-250.91,10131,-552.78,-3104.3,5757.8,1868.8,-3374.6,1832.4,575.78,-112.19]

def part2():
    plan = np.random.uniform(-1,1, 40)
    split = int(sys.argv[2])

    plan[:split] = start_plan[:split]

    initial_dist = sim(plan)
    cur_dist = initial_dist
    print "Initial distance = ", initial_dist

    prev_plan = copy.deepcopy(plan) + .001
    step_size = .1
    beta = .1
    num_iterations = 1

    best_plan_yet = copy.deepcopy(plan)
    best_dist = initial_dist


    while(np.linalg.norm(prev_plan - plan) > 1e-9):
        new_plan = copy.deepcopy(plan)
        cur_dist = sim(plan)
        for i in range(split,len(plan)):
            #In this case we want gradient ascent, to maximize our objective function
            new_plan[i] = plan[i] + step_size*sim_analytical_gradient(plan, i, cur_dist) - beta*(plan[i] - prev_plan[i])
        new_dist = sim(new_plan)

        prev_plan = plan
        plan = new_plan
        print "new dist = ", new_dist
        
        num_iterations += 1

        if(new_dist > best_dist):
            best_dist = new_dist
            best_plan_yet = new_plan
            print "new best distance ", best_dist
        if(num_iterations % 25 == 0):
            print list(best_plan_yet)            

    
def sim_analytical_gradient(x, i, sim_x):
    h = 1e-9
    x_plus_h = copy.deepcopy(x)
    x_plus_h[i] += h
    grad = (sim(x_plus_h) - sim_x)/h
    #print i, grad
    #raw_input("")
    return grad

def part1():
    plt.ylabel("Average Number of Iterations")
    plt.xlabel("Step Size")
    step_sizes = [y/100.0 for y in range(1,51)]

    if(sys.argv[2] == "b"):
        average_iters = gradient_descent(obj_fct_b, gradient_b, step_sizes, 0)
        plt.title("Part 1b", fontsize=24)
        plt.plot(step_sizes, average_iters)

    if(sys.argv[2] == "c"):
        average_iters = gradient_descent(obj_fct_c, gradient_c, step_sizes, 0)
        plt.title("Part 1c", fontsize=24)
        plt.plot(step_sizes, average_iters)

    if(sys.argv[2] == "d"):
        colors = ['r', 'b', 'g', 'y', 'k']
        for index, beta in enumerate([0, .1, .25, .5, .75]):
            if(sys.argv[3] == "1"):
                average_iters = gradient_descent(obj_fct_b, gradient_b, step_sizes, beta)

            elif(sys.argv[3] == "2"):
                step_sizes = [y/500.0 for y in range(1,51)]
                average_iters = gradient_descent(obj_fct_c, gradient_c, step_sizes, beta)

            plt.plot(step_sizes, average_iters, color=colors[index], label = "beta = " + str(beta))
        plt.legend(loc='center')
        plt.title("Part 1d, (" + sys.argv[3] + ")", fontsize=24)
    
    plt.show()


def gradient_b(xi, i):
    return (1+i/10.0)*2*xi

def gradient_c(xi, i):
    return np.power(2, (i+1)/2.0)*2*xi

def gradient_descent(obj_fct, grad_fct, step_sizes, beta):
    average_iters = []
    for step_size in step_sizes:
        print "Step Size: ", step_size
        total_iters = 0
        became_nan = False
        for trial in range(10):
            x = np.random.uniform(-100, 100, 10)
            prev_x = x
            while(obj_fct(x) > 0.0000001):
                new_x = np.zeros_like(x)
                for i in range(len(x)):
                    #print "gradient = ", grad_fct(x[i], i)
                    new_x[i] = x[i] - step_size*grad_fct(x[i], i) + beta*(x[i] - prev_x[i])
                    if(math.isnan(new_x[i])):
                        #print "number is nan"
                        #raw_input("")
                        became_nan = True
                prev_x = x
                x = new_x
                total_iters += 1

        if(became_nan):
            average_iters.append(0)
        else:
            average_iters.append(total_iters/10)
        #print "Step size ", step_size
        print total_iters/10
    return average_iters


def obj_fct_c(x):
    total = 0
    for i in range(len(x)):
        xi = x[i]
        total += np.power(2,(i+1)/2.0)*(xi*xi)
    return total    


#Calculates value of objective function
def obj_fct_b(x):
    total = 0
    for i in range(len(x)):
        xi = x[i]
        total += (1+i/10.0)*(xi*xi)
    return total



if __name__ == "__main__":
    main()